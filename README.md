Desc algorithm
Данный алгоритм работает таким образом: 
создается очередь, в которую помещается в начале элемент, с которого нужно начинать поиск, а во всех последующих итерациях цикла while - туда помещаются его ближние элементы (верхний от рассматриваемого, левый, нижний, и правый) , но только те, которые были заранее отобраны по критериям : 
не является шаром (единицей)
не является несуществующим элементом (за гранью массива)
суть цикла такова - у каждого рассматриваемого элемента есть свой ключ в переменной graph, у которого есть значение на этот ключ (от 0 до 4ех элементов), 0 - когда у него нет подходящих ближних элементов под критерии отбора(описан ранее) , 4 - когда все элемента(верхний, левый, нижний, правый) тоже являются возможными к "прохождению" . все эти элементы мы помещаем во временный массив wayss, который перебираем и смотрим на каждый из них(цикл for), если данный элемент мы уже рассматривали - пропускаем его, в ином случае - добавляем его в очередь и в словарь пройденных элементов path (который потом понадобится для вычисления и  отображения пути на матрице). Так же , до того как рассмотреть очередной элемент, сперва он выходит из очереди, а только потом рассматривается. Так же, есть преждевременный выход из цикла while, когда найден елемент, который совпадает по значению с finish - выходим из while, это означает, что цель найдена. Если же не удалось найти искомый элемент, значит он находится вне зоны досягаемости от стартовой точки. 
После окончания работы цикла while, мы либо видим, что путей до точки "finish" нет, либо записываем пути . Выход из функции. 
Таким образом, с помощью работы двух главных элементов этого алгоритма, решается проблема поиска путей, а в будущем, и нахождения кратчайшего из них.
P.S. прошу прощения за нейминг и другие нюансы, не было времени исправить.
